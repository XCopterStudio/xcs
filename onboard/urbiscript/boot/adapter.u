class Adapter {
    var _socket;
    var output;

    function init() {
        output = Object.clone();
    };

    function start(server, port) {
        _socket = Socket.new();
        _socket.connect(server, port);
        var receiveMtx = Mutex.new();
        at (_socket.received?(var data)) receiveMtx: {
            output = data;
        };
        clog << "Started adapter %s:%s." % [server, port];
    };

    function send(data) {
        assert(_socket != nil);
        _socket.write(data);
    };
}|;

class FlashSender {
    function init(adapter, UJson) {
        var this.adapter = adapter;
        var this.ujson = UJson;
    }|;

    function send(message) {
        var data = [ => ];
        data["type"] = "flash";
        data["data"] = message;
        this.adapter.send(this.ujson.encode(data) + "\n");
    }|;
}|;

class SemanticSender {
    function init(adapter, inputs, UJson, refreshFrequency) {
        var that = this;
        var this._inputs = [ => ];
        var this.adapter = adapter;
        var this.period = 1 / refreshFrequency;

        for(var input: inputs) {
            setSlot(input.first, nil); // slot for outer "writers"
            _inputs[input.first] = nil; // last stored value
            var slot = getSlot(input.first);
            slot.notifyChange(function() {
                that._inputs[input.first] = that.getSlotValue(input.first);
            });
        };
    }|;
    
    function start() {
        every(this.period) {
                var dataToSend = [ => ];
                for(var input: _inputs) {
                    if(!this._inputs[input.first].isNil) {
                        dataToSend[input.first] = this.getSlotValue(input.first);
                    }
                };
                if(dataToSend.size > 0) {
                    var serialized = UJson.encode([
                        "type" => "data",
                        "data" => dataToSend
                    ]);

                    this.adapter.send(serialized + "\n");                    
                }
        };
    }|;
}|;

class SemanticReceiver {
    var onboardMode;
    var receivers = Dictionary.new();
    var messageBuffer;

    function init(adapter, json) { // parseJson as arg, lookup is wierd in this case (TODO package/import? or Global)
        messageBuffer = "";
        
        at(adapter.output->changed?) {

            // tryDecode and messageBuffer handles the case when too big message is comming and is cut to more parts
            if(json.hasSlot("tryDecode")) {     // working with xjson
                /* This handles the case when more JSON objects are present in the buffer */
                var messageArray = (messageBuffer + adapter.output).replace("}\n{", "},{");

                if(json.tryDecode(messageArray)) {
                    messageBuffer = json.outRest;
                    var rawMessages = json.outJson;

                    for(var rawData: rawMessages) {
                        var type = rawData["type"];
                        var data = rawData["data"];
                        if (receivers.has(type)) {
                            receivers[type].receive(data);
                        } else {
                            echo("Unhandled message from Server of type: " + rawData["type"]);
                        }
                    };
                }
                else {
                    messageBuffer = messageArray;
                };

                if(messageBuffer != "") {
                    //echo("Save massage from server to buffer: " + messageBuffer);
                    echo("Save massage from server to buffer.");
                };
            }
            else {  // working with ujson
                /* This handles the case when more JSON objects are present in the buffer */
                var messageArray = "[" + adapter.output.replace("}\n{", "},{") + "]";

                var rawMessages = json.decode(messageArray);
                for(var rawData: rawMessages) {
                    var type = rawData["type"];
                    var data = rawData["data"];
                    if (receivers.has(type)) {
                        receivers[type].receive(data);
                    } else {
                        echo("Unhandled message from Server of type: " + rawData["type"]);
                    };
                }
            }
        };
    };

    function addReceiver(receiver) {
        receivers[receiver.typeName] = receiver;
    };
}|;

var Global.SemanticReceiver = this.SemanticReceiver|;

class Receiver {
    var typeName;
    var outputs;

    function init(type, outputs) {
        this.typeName = type;
        this.outputs = outputs;
        for(var output: outputs) setSlot(output.first, nil);
    };

    var receive = function (data) {
        for(var output: outputs) {
            var name = output.first;
            if(name in data) {
                this.updateSlot(name, data[name]);
            };
        };
    };
}|;

var Global.Receiver = this.Receiver|;

class OnboardReceiver {
    var request = "";

    function init(adapter, json) {
       var onboardReceiver = Global.Receiver.new("onboard", [
            "request" => "request"
        ]);
        var semanticReceiver = Global.SemanticReceiver.new(adapter, json);
        semanticReceiver.addReceiver(onboardReceiver);

        onboardReceiver.&request >> this.&request;
    }
}|;

class OnboardSender {
    function init(adapter, json) {
        var this.adapter = adapter;
        var this.json = json;
    };

    function sendMode(mode) {
        sendData("mode", mode);
        //var data = [ => ];
        //data["type"] = "onboard";
        //data["data"] = [ "mode" => mode ];
        //this.adapter.send(this.json.encode(data) + "\n");
    };

    function sendDataFlowGraph(dataFlowGraphData) {
        sendData("dataFlowGraph", dataFlowGraphData);
    };

    function sendPrototype(prototypesData) {
        sendData("prototype", prototypesData);
    };

    function sendClone(clonesData) {
        sendData("clone", clonesData);
    };

    function sendPrototypeClone(prototypeData, cloneData) {
        sendData(["prototype", "clone"], [prototypeData, cloneData]);
    };

    function sendDfg4Load(dfgs) {
        sendData("savedDfg", dfgs);
    };

    function sendLoadDfg(dfg) {
        sendData("dfgDef", dfg);
    };

    function sendResponse(id, responseType, responseData, requestId) {
        var response = [ => ];
        response["id"] = id;
        response["respondType"] = responseType;
        response["respondData"] = responseData;
        response["requestId"] = requestId;

        sendData("response", response);
    };

    function sendData(type, typesData) {
        //prepare data type 
        var data = [ => ];
        data["type"] = "onboard";

        // prepare data
        if(typesData.isA(List) && type.isA(List)) {
            var maxIndex = Math.max(typesData.size(), type.size());
            var tData = [ => ];
            for(var i: maxIndex) {
                tData[type[i]] = typesData[i];
            };
            data["data"] = tData;
        }
        else {
            data["data"] = [ type => typesData ];
        };

        //send data
        this.adapter.send(this.json.encode(data) + "\n");
    };
}|;