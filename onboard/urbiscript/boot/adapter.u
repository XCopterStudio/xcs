class Adapter {

    var _socket;
    var output;

    function init() {
        output = Object.clone();
    };

    function start(server, port) {
        _socket = Socket.new();
        _socket.connect(server, port);
        var receiveMtx = Mutex.new();
        at (_socket.received?(var data)) receiveMtx: {
            output = data;
        };
        clog << "Started adapter %s:%s." % [server, port];
    };

    function send(data) {
        assert(_socket != nil);
        _socket.write(data);
    };
}|;

class FlashSender {

    function init(adapter, UJson) {
        var this.adapter = adapter;
        var this.ujson = UJson;
    }|;

    function send(message) {
        var data = [ => ];
        data["type"] = "flash";
        data["data"] = message;
        this.adapter.send(this.ujson.encode(data) + "\n");
    }|;
}|;
//TODO rename inputs to outputs in receiver
//TODO rename outputs to inputs in sender

class SemanticSender {

    function init(adapter, outputs, UJson, refreshFrequency) {
        var that = this;
        var this._outputs = [ => ];
        var this.adapter = adapter;
        var this.period = 1 / refreshFrequency;

        for(var output: outputs) {
            setSlot(output.first, nil); // slot for outer "writers"
            _outputs[output.first] = nil; // last stored value
            var slot = getSlot(output.first);
            slot.notifyChange(function() {
                that._outputs[output.first] = that.getSlotValue(output.first);
            });
        };
    }|;
    
    function start() {
        every(this.period) {
                var dataToSend = [ => ];
                for(var output: _outputs) {
                    if(!this._outputs[output.first].isNil) {
                        dataToSend[output.first] = this.getSlotValue(output.first);
                    }
                };
                if(dataToSend.size > 0) {
                    var serialized = UJson.encode([
                        "type" => "data",
                        "data" => dataToSend
                    ]);

                    this.adapter.send(serialized + "\n");                    
                }
        };
    }|;
}|;

class SemanticReceiver {
    function init(adapter, inputs, UJson) { // parseJson as arg, lookup is wierd in this case (TODO package/import? or Global) 
        for(var input: inputs) setSlot(input.first, nil);

        var that = this;
        at(adapter.output->changed?) {
            /* This handles the case when more JSON objects are present in the buffer */
            var messageArray = "[" + adapter.output.replace("}\n{", "},{") + "]";
            var rawMessages = UJson.decode(messageArray);
            for(var rawData: rawMessages) {
                var data = rawData["data"];
                for(var input: inputs) {
                    var name = input.first;
                    if(name in data) {
                        that.updateSlot(name, data[name]);
                    };
                };
            };
        };
    };
}|;
