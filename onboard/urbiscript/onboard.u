System.system("start cmd.exe /k \"node d:/skola/MFF/Mgr/swProjekt/quadricopter/repository/xcs/server/server.js\"")|;
sleep(2s);

class Onboard {
    
    class XcsPaths {
        var scripts = {if("XCS_SCRIPTS_PATH" in System.env) System.env["XCS_SCRIPTS_PATH"] else Path.cwd / "urbiscript"};
        var settings = {if("XCS_SETTINGS_PATH" in System.env) System.env["XCS_SETTINGS_PATH"] else Path.cwd / "xsettings"};

        function getScript(filename) {
            echo("/////////////////////" + scripts);

            scripts / filename;
        }|;

        function getSettings(filename) {
            settings / filename;
        }|; 
    }|;
    
    var xobjects4load_ = [ => ];            // list of pairs (xobjects, which are yet not loaded; path)
    var loadedXObjects_ = [ => ];           // list of pairs (loaded xobjects; copies)
    var loadedPrivateObjects_ = [ => ];     // list of pairs (loaded uobjects; copies)
    var privateObjects_ = [];               // objects, which are not visible for user
    var ddfg_ = "";                // data flow graph
    var dfgCommStarted_ = false;            // data flow graph communication started
    var onboardSender_;
    var onboardReceiver_;
    var xobjectsSettings_;
    var xobjectInfo_ = [ => ];
    var dfgLobby_;
    var json_;
    var xobjectStates_ = [ "STATE_CREATED" => 0, "STATE_STARTED" => 1, "STATE_STOPED" => 2];

    function init() {
        this.dfgLobby_ = Lobby.create();

        loadSettings_();

        loadCore_();

        // initialize onboard sender 4 communication with server
        var this.adapter = Adapter.new();
        adapter.start("127.0.0.1", 1234);
        this.json_ = XJson.new();
        this.onboardSender_ = OnboardSender.new(adapter, this.json_);

        // initialize sending information about data flow graph
        initDfgCommunication_();
        //startDfgCommunication();

        // initialize onboard receiver 4 communication with server
        this.onboardReceiver_ = OnboardReceiver.new(adapter, this.json_);
        at(this.onboardReceiver_.&request.changed?) {
            doRequest_(this.onboardReceiver_.request);
        };

        // find all possible xobjects
        loadXObjectsPath_();
        
        sleep(1s);

        //loadXObject_("xci dodo");
        loadXobjects4load_();

        // load ddfg from settings
        loadDdfg_();
    };

    function doRequest_(request) {
        if(request.has("id") && request.has("requestData") && request.has("requestId")) {
            var id = request["id"];
            var requestData = request["requestData"];
            var requestId = request["requestId"];
            var responseData = "";
            var responseType = "Done";

            //debug
            if(requestData == "") {
                echo("receive request: " + id);
            } else {
                echo("receive request: " + id + " (data: " + requestData + ")");
            };

            try {
                switch(id) {
                    case "DFG_LOAD":
                        responseData = doDfgLoad_();
                    case "DFG_CREATE":
                        responseData = doDfgCreate_(requestData);
                    case "DFG_START":
                        responseData = doDfgStart_(requestData);
                    case "DFG_STOP":
                        responseData = doDfgStop_(true, requestData);
                    case "DFG_RESET":
                        responseData = doDfgReset_(true, requestData);
                    case "DFG_SAVE":
                        responseData = doDfgSave_(requestData);
                    case "SAVED_DFG":
                        responseData = doSavedDfg_();
                    case "LOAD_DFG":
                        responseData = doLoadDfg_(requestData);
                    default:
                        echo("...unknown request");
                        responseData = "Unknown request: " + id + ".";
                        responseType = "Error";
                };
            }
            catch(var ex) {
                //TODO: what to do with errors? send to client? + send current state (all created/started/stopped nodes)
                echo("ERROR(" + id + "): " + ex.asString());
                responseData = ex.message;
                responseType = "Error";
            };

            try {
                this.onboardSender_.sendResponse(id, responseType, responseData, requestId);
            }
            catch(var ex) {
                echo("ERROR while try to send respond: " + ex.asString());
            };
        }
        else {
            //TODO: what to do with errors? send to client?
            echo("ERROR(doRequest): bad request format: " + request.asString());
        };
    };

    // stop all xobjects and delete them and optionally resend info about loaded xobjects
    function doDfgReset_(resend, requestData = nil) {
        var destroyedXo = [];

        // stop all xobjects
        doDfgStop_(false, requestData);

        //delete all xobjects - should call destructors
        for(var slot: this.dfgLobby_.localSlotNames()) {
            if(requestData.isNil() || requestData == "" || requestData == slot) {
                this.dfgLobby_.getLocalSlot(slot).value = nil;
                this.dfgLobby_.removeLocalSlot(slot);

                destroyedXo << slot;
            };
        };

        // send info about loaded xobjects
        var data = [ => ];
        if(resend && (requestData.isNil() || requestData == "")) {
            data = doDfgLoad_();
        };

        data["destroyed"] = destroyedXo;

        return data;
    };

    // stop all xobjects
    function doDfgStop_(checkStopped, requestData = nil) {
        var stopped = false;
        var stoppedXo = [];

        for(var slot: this.dfgLobby_.localSlotNames()) {
            var xo = this.dfgLobby_.getLocalSlot(slot).value();
            if(xo.hasSlot("stopXO") && xo.hasSlot("getState") && xo.getState() == this.xobjectStates_["STATE_STARTED"]) {
                if(requestData.isNil() || requestData == "" || requestData == slot) {
                    xo.stopXO();
                    stopped = true;
                    stoppedXo << slot;
                };
            };
        };

        if(!stopped && checkStopped) {
            throw Exception.new("nothing to stop");
        };

        return stoppedXo;
    };

    // start all xobjects
    function doDfgStart_(requestData = nil) {
        var started = false;
        var startedXo = [];

        for(var slot: this.dfgLobby_.localSlotNames()) {
            var xo = this.dfgLobby_.getLocalSlot(slot).value();
            if(xo.hasSlot("startXO") && xo.hasSlot("getState") && xo.getState() != this.xobjectStates_["STATE_STARTED"]) {
                if(requestData.isNil() || requestData == "" || requestData == slot) {
                    xo.startXO();
                    started = true;
                    startedXo << slot;
                };
            };
        };
        
        if(!started) {
            throw Exception.new("nothing to start");
        };

        return startedXo;
    };
    
    // reset old dfg and create new one
    function doDfgCreate_(requestData) {
        var created = false;

        try {
            // prototypes
            for(var p: requestData["prototype"]) {
                var id = p["id"];
                var name = p["name"];

                if(!this.dfgLobby_.hasLocalSlot(id)) {
                    var createPart = "";
                    if(this.xobjectInfo_.has(name)) {
                        createPart = this.xobjectInfo_[name].name + ".new(" + this.xobjectInfo_[name].initParam + ")";
                    }
                    else {
                        createPart = id + ".()";
                    };

                    this.dfgLobby_.setSlot(id, System.eval(createPart + ";"));
                    created = true;
                };
            };

            // links
            for(var l: requestData["link"]) {
                var sourceId = l["source"]["id"];
                var sourcePort = l["source"]["port"];
                var targetId = l["target"]["id"];
                var targetPort = l["target"]["port"];

                if(this.dfgLobby_.hasLocalSlot(sourceId) && this.dfgLobby_.hasLocalSlot(targetId)) {
                    var source = this.dfgLobby_.getLocalSlot(sourceId).value();
                    var target = this.dfgLobby_.getLocalSlot(targetId).value();

                    if(source.hasLocalSlot(sourcePort) && target.hasLocalSlot(targetPort)) {
                        source.getLocalSlot(sourcePort) >>  target.getLocalSlot(targetPort);
                    };
                };
            };

            // register xvars
            for(var r: requestData["registerXVar"]) {
                var sourceId = r["source"]["id"];
                var sourcePort = r["source"]["port"];
                var targetId = r["target"]["id"];
                var targetPort = r["target"]["port"];

                if(this.dfgLobby_.hasLocalSlot(sourceId) && this.dfgLobby_.hasLocalSlot(targetId)) {
                    var source = this.dfgLobby_.getLocalSlot(sourceId).value();
                    var target = this.dfgLobby_.getLocalSlot(targetId).value();

                    if(source.hasLocalSlot(sourcePort) && target.hasLocalSlot(targetPort)) {
                        // get source/target slot names
                        var sourceSlot = source.getLocalSlot(sourcePort); 
                        var targetSlot = target.getLocalSlot(targetPort);

                        // get data types
                        var synT = source.getSynType(sourcePort);
                        var semT = source.getSemType(sourcePort);

                        // execute register xvar method
                        targetSlot.value(sourcePort, semT, synT, sourceSlot);
                    };
                };
            };
        }
        catch(var ex) {
            doDfgReset_(false);
            throw ex;
        };

        if(!created) {
            throw Exception.new("nothing to create");
        }; 

        return this.dfgLobby_.localSlotNames();
    };

    // start dfg communication and send info about loaded xobjects and default dfg
    function doDfgLoad_() {
        var prototypeData = getNodesPrototypesInfo_();
        var prototypePrivateData = getNodesPrototypesInfo_(true);
        //var cloneData = getNodesCloneInfo_();
        var ddfgData;

        var data = [ => ];
        data["prototype"] = prototypeData;
        //data["clone"] = cloneData;
        data["prototypePrivate"] = prototypePrivateData;
        data["ddfg"] = this.ddfg_;

        return data;
    };

    function doDfgSave_(requestData) {
        var filename = requestData["filename"];
        var rewrite = requestData["rewrite"];
        var dfg = requestData["DFG"];

        //var filePath = getUserDfgPaths_()[0] / Path.new(filename);
        var filePath = getUserDfgPaths_(filename, false)[0];
        var setting = XSettings.new(filePath.asString(), rewrite);
        setting.setAndSave("DFG", dfg);

        //resend info about saved dfg
        return doSavedDfg_();
    };

    function doSavedDfg_() {
        var filePaths = getUserDfgPaths_();
        var dfgs = [];
        for(var path: filePaths) {
            dfgs += XSettings.getSettingsFiles(path.asString(), "DFG");
        };
 
        var data = [ => ];
        data["savedDfg"] = dfgs;

        return data;
    };

    function doLoadDfg_(filename) {
        //var filePath = getUserDfgPaths_() / Path.new(filename);
        var filePath = getUserDfgPaths_(filename)[0];
        var setting = XSettings.new(filePath.asString(), false);
        var dfg = [ => ]; 
        dfg["filename"] = filename;
        dfg["DFG"] = setting.get("DFG");
        
        return dfg;
    };

    // initialize sending information about data flow graph
    function initDfgCommunication_() {
        // initialization 4 sending information about current data flow graph
        this.ddfg_ = "";
        at(this.&ddfg_.changed?) {
            if(this.dfgCommStarted_) {
                sendDdfg_();
            };
        };

        // initialization 4 sending information about xobjects
        var this.loadedXObjectsEvent_ = this.loadedXObjects_.elementAdded.'||'(this.loadedXObjects_.elementChanged).'||'(this.xobjects4load_.elementAdded);
        at(this.loadedXObjectsEvent_?) {
            if(this.dfgCommStarted_) {
                sendNodesInfo_();
            };
        };
    };

    function sendDdfg_() {
        this.onboardSender_.sendDdfg(this.ddfg_);
    };

    ///[Obsolete("send DFG_LOAD request instead")]
    function sendNodesInfo_() {
        var prototypesData = getNodesPrototypesInfo_();
        var clonesData = getNodesCloneInfo_();

        // send data
        echo("sending info");
        this.onboardSender_.sendPrototypeClone(prototypesData, clonesData);
    };

    function getNodesPrototypesInfo_(prototypePrivate = false) {
        var prototypeData = [];

        //debug
        if(prototypePrivate) {
            echo(".sending info about PRIVATE xobject:");
        }
        else {
            echo(".sending info about PUBLIC xobject:");
        };

        // prepare data for yet not loaded xobjects
        for(var kvpXO: this.xobjects4load_) {
            var pData = getNodeData_(kvpXO.first().asString(), prototypePrivate);
            
            if(!pData.empty()) {
                prototypeData << pData;
            };
        };

        // prepare data for loaded xobjects
        if(prototypePrivate) {
            for(var l: this.loadedPrivateObjects_) {
                prototypeData << getNodeData_(l.first().asString());
            };
        }
        else {
            for(var l: this.loadedXObjects_) {
                prototypeData << getNodeData_(l.first().asString());
            };
        };

        return prototypeData;
    };

    function getNodeData_(key, prototypePrivate = false) {
        var pData = [ => ];

        try {
            echo("...sending info about loaded xobject: " + key);

            // determine if we have enough information about current key
            if(this.xobjectInfo_.has(key)) {
                var name = this.xobjectInfo_[key].name;

                // get info about xvars and input ports
                var xvars = System.eval(name + ".getXVars()");
                var xinputPorts = System.eval(name + ".getXInputPorts()");
                
                // get info and prepare data about registerXVar functions
                var registerXVars = [];
                if(System.eval(name + ".hasSlot(\"registerXVar\");")) {
                    registerXVars << "registerXVar";
                };

                // prepare data about xvars
                var varList = [];
                for(var xv: xvars) {
                    var pVar = [ => ];
                    pVar["name"] = xv;
                    pVar["synType"] = System.eval(name + ".getSynType(\"" + xv + "\")");
                    pVar["semType"] = System.eval(name + ".getSemType(\"" + xv + "\")");
                    varList << pVar;
                };

                // prepare data about input ports
                var portList = [];
                for(var xip: xinputPorts) {
                    var pPort = [ => ];
                    pPort["name"] = xip;
                    pPort["synType"] = System.eval(name + ".getSynType(\"" + xip + "\")");
                    pPort["semType"] = System.eval(name + ".getSemType(\"" + xip + "\")");
                    portList  << pPort;
                };

                pData["name"] = key;
                pData["var"] = varList;
                pData["inputPort"] = portList;
                pData["registerXVar"] = registerXVars;
            }
            else {
                echo("...there is no info for: " + key);
                //TODO: move object to loadedPrivateObjects and erase it from loadedXObject (we are in foreach loop...)
                //if(!this.loadedPrivateObjects_.has(key)) {
                //    this.loadedPrivateObjects_[p.first()] = p.second()
                //}

                //TODO: not tested
                // dont send info about private/not private objects
                var end = this.privateObjects_.has(key);
                if(prototypePrivate) {
                    end != end;
                };

                if(end) {
                    if(prototypePrivate) {
                        echo("... " + key + " is NOT private object - doesnt send info.");
                    }
                    else {
                        echo("... " + key + " is private object - doesnt send info.");
                    };
                }
                else {
                    try {
                        pData["name"] = key;
                    }
                    catch(var ex){
                        echo("!!!!!ERROR: " + ex.asString());
                        pData.clear();
                    };
                };
            };
        }
        catch(var ex) {
            echo("ERROR: " + ex.asString());
        };

        return pData;
    };

    function getNodesCloneInfo_() {
        var clonesData = [];

        return clonesData;
    };

    function startDfgCommunication() {
        this.dfgCommStarted_ = true;
    };

    function stopDfgCommunication() {
        this.dfgCommStarted_ = false;
    };

    function loadScripts_(uscriptList) {
        for(var script: uscriptList) {
            this.loadScript_(script);
        };
    };

    function loadScript_(script) {
        try {
            var path = XcsPaths.getScript(script);
            load(path);
            echo("loaded script " + script);
        }
        catch(var ex){
            echo("...script cannot be load: " + ex.asString());
        };
    };

    function loadXobjects4load_() {
        var laoded = false;

        // copy of xobjects4load_ - function loadXObject_ erase from dictionary loadXObject_ - we should not iterate through this dictionary
        var xos = [ => ];
        for(var xo: this.xobjects4load_) {
            xos[xo.first()] = xo.second();
        };

        // send just one dfg info - it is not thread safety
        var started = this.dfgCommStarted_;
        try {
            this.stopDfgCommunication();
            for(var xo: xos) {
                var b = loadXObject_(xo.first());
                laoded = laoded || b;
            };
        }
        finally {
            if(started) {
                this.startDfgCommunication();
                if(laoded) {
                    this.loadedXObjects_.elementAdded!;
                };
            };
        };
    };

    function loadXObjects_(xobjectsPath) {
        var laoded = false;
        
        // send just one dfg info - it is not thread safety
        var started = this.dfgCommStarted_;
        try {
            this.stopDfgCommunication();
            for(var xo: xobjectsPath) {
                var b = loadXObject_(xo);
                laoded = laoded || b;
            };
        }
        finally {
            if(started) {
                this.startDfgCommunication();
                if(laoded) {
                    this.loadedXObjects_.elementAdded!;
                };
            };
        };
    };

    function loadXObject_(xobjectPath, xobjectName = nil, addToRegister = true) {
        //log
        echo("loading xobject: " + xobjectPath.asString() + "...");

        // find xobject name
        var filename;
        if(xobjectPath.isA(Path)){  // param is exact path
            filename = xobjectPath.basename.split(".").front();
            echo("...filename from path: " + filename);
        }
        else if(this.xobjects4load_.has(xobjectPath)) {   // param from registred xobjects load
            filename = this.xobjects4load_[xobjectPath].basename.split(".").front();
            echo("...filename from 4 load: " + filename);
        }
        else if(this.xobjectInfo_.has(xobjectPath)) { // param from settings
            filename = this.xobjectInfo_[xobjectPath].filename;
            echo("...filename from info: " + filename);
        }
        else {  //param is filename
            filename = xobjectPath.asString();
            echo("...filename: " + filename);
        };

        //find all xobject in file with current filename
        var xobjectsNames = [];
        for(var xoi: this.xobjectInfo_) {
            if(xoi.second().filename == filename) {
                xobjectsNames << xoi.first();
            };
        };
        if(xobjectsNames.empty()) {
            xobjectsNames << filename;
        };

        // check if it is not already loaded
        var xoName = xobjectsNames.front();
        var added = false;
        if(this.loadedXObjects_.has(xoName) || this.loadedPrivateObjects_.has(xoName)) {
            echo("...xobject already loaded");
        }
        else {  //load module
            try {
                echo("...loading module: " + filename);
                System.loadModule(filename);

                if(addToRegister) {
                    // send just one dfg info - it is not thread safety
                    var started = this.dfgCommStarted_;
                    try {
                        this.stopDfgCommunication();

                        for(var xon: xobjectsNames) {
                            echo("...loading xobject: " + xon);
                            var name = xon;
                            if(!xobjectName.isNil()) {
                                name = xobjectName;
                            };

                            if(this.privateObjects_.has(xon) || !this.isXObject_(name)) {
                                this.loadedPrivateObjects_[xon] = List.new();
                                echo("...xobject is private (" + this.privateObjects_.has(xon) + ") (" + !this.isXObject_(xon) + ")");
                            }
                            else {
                                this.loadedXObjects_[xon] = List.new();
                                added = true;
                            };
                            //echo("...xobject loaded");
                        };
                    }
                    finally {
                        if(started) {
                            this.startDfgCommunication();
                            if(added) {
                                this.loadedXObjects_.elementAdded!;
                            };
                        };
                    };
                };
            }
            catch(var ex) {
                echo("...xobject not found! " + ex.asString());
            };
        };

        //erase record from 4load
        if(addToRegister) {
            for(var xon: xobjectsNames) {
                if(this.xobjects4load_.has(xon)) {
                    this.xobjects4load_.erase(xon);
                    echo("...xobject erase from array of xobjects 4 load");
                };
            };
        };

        return added;
    };

    function isXObject_(key) {
        // find name for key
        var name;
        if(this.xobjectInfo_.has(key)) {
            name = this.xobjectInfo_[key].name;
        }
        else {
            name = key;
        };
        
        // determin if object "name" has xobject slot getXVars
        try {
            if(System.eval(name + ".hasSlot(\"getXVars\");")) {
                return true;
            };
        }
        catch(var ex) {
          //echo("///////////////" + key + " exception: " + ex.asString());
        };

        return false;
    };

    function loadXObjectsPath_() {
        // xobjects
        var xobjectsFE = ["dll", "so"];

        // remember dfg communication state
        var commStarted = this.dfgCommStarted_;
        var added = false;
        var otherFiles = [];

        try {
            // stop dfg communication - it sends 
            this.stopDfgCommunication();

            // find all xobjects
            for(var dirPath: UObject.searchPath) {
                var dir = Directory.new(dirPath);
                for(var path: dir.asList()) {
                
                    if(xobjectsFE.has(path.basename().split(".").back()) && this.xobjectsSettings_.containsPath(path)) {
                        var m = this.xobjectsSettings_.getXObjectSettingsFromPath(path);
                        for(var kvp: m) {
                            if(!(this.xobjects4load_.has(kvp.first()) && this.xobjectInfo_.has(kvp.first()))) {
                                this.xobjectInfo_[kvp.first()] = kvp.second();
                                this.xobjects4load_[kvp.first()] = path;
                                added = true;
                            };
                        };
                    }
                    else {
                        otherFiles << path;
                    };
                };
            };
        }
        finally {
            if(commStarted) {
                this.startDfgCommunication();
                if(added) {
                    this.xobjects4load_.elementAdded!;
                };
            };
        };

        //DEBUG: log
        //echo("loading xobjects path...");
        //echo("...founded xobjets: " + this.xobjects4load_.asString());
        //echo("...founded other files: " + otherFiles.asString());
    };

    function loadSettings_() {
        //load settings
        loadXObject_("xsettings", "XSettings", false);
        loadScript_("settings_collection.u");

        // load xobjcts paths
        var xobjectsPaths = this.getXObjectSettingFilePaths_();
        var xobjectsPrivatePaths = this.getXObjectSettingFilePaths_(true);
        
        // mark private xobjects as private
        this.xobjectsSettings_ = SettingsCollection.new(xobjectsPrivatePaths);
        var modules = this.xobjectsSettings_.getMap();
        for(var module: modules) {
            var xobjects = this.xobjectsSettings_.getXObjectSettings(module.first());
            for(var xobject: xobjects) {
                if(!this.privateObjects_.has(xobject.first())) {
                    this.privateObjects_ << xobject.first();
                };
            };
        };

        // load settings for public/private xobjects
        this.xobjectsSettings_ = SettingsCollection.new(xobjectsPaths + xobjectsPrivatePaths);
    };

    function loadDdfg_() {
        var ddfgPath = XcsPaths.getSettings("ddfg.xs");

        if(!ddfgPath.isNil()) {
            var setting = XSettings.new(ddfgPath.asString(), false);
            this.ddfg_ = setting.get("DFG");
        };
    };

    function loadCore_() {
       // module names to be loaded
        var moduleList = [
            "xjson",
            "ujson",
        ];

        // load listed modules
        loadXObjects_(moduleList);

        // bootstrap urbiscripts
        var uscriptList = [
            "boot/adapter.u"
        ];

        loadScripts_(uscriptList);
    };

    function getXObjectSettingFilePaths_(xobjectsPrivate = false) {
        if(xobjectsPrivate) {
            /*return*/ [XcsPaths.getSettings("xobjectsPrivate.xs")];
        } else {
            /*return*/ [XcsPaths.getSettings("xobjects.xs")];
        };        
    };

    function getUserDfgPaths_(file = nil, checkExists = false) {
        var type = "DFG/";
        if(!file.isNil()) {
            type += file;
        };
        var paths = getUserDataPaths_(type, file.isNil(), checkExists);
        
        if(!file.isNil()) {
            var existedPaths = [];
            for(var p: paths) {
                if(p.exists()) {
                    existedPaths << p;
                };
            };

            if(existedPaths.size() > 0) {
                return existedPaths;
            };
        };
        
        return paths;
    };

    function getUserDataPaths_(type, isDir, checkExists) {
        var basePaths = [XcsPaths.getSettings("userdata") / Path.new(type)];

        var dirPaths = [];
        for(var p: basePaths) {
            if(!checkExists || (p.exists() && ((isDir && p.isDir()) || (!isDir && p.isReg())))) {
                dirPaths << p;
            };
        };

        return dirPaths;
    };
}|;


var onboard = Onboard.new() |;
